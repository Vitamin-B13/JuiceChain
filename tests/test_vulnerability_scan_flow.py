from juicechain.core import vulnerability as vuln


def _make_sql_error_finding(pt: vuln.InputPoint) -> vuln.Finding:
    return vuln.Finding(
        type="SQLI_ERROR",
        severity="high",
        evidence="simulated SQL error",
        request={"method": pt.method, "path": pt.path, "location": pt.location, "param": pt.param},
        response=None,
        timestamp=0,
    )


def test_scan_vulnerabilities_calls_boolean_once_per_point(monkeypatch):
    pt = vuln.InputPoint(method="GET", path="/rest/products/search", location="query", param="q")

    monkeypatch.setattr(vuln, "derive_input_points_from_scan", lambda doc: [pt])
    monkeypatch.setattr(vuln, "check_reflected_xss", lambda **kwargs: None)
    monkeypatch.setattr(vuln, "check_sqli_error", lambda **kwargs: None)

    calls = {"boolean": 0}

    def _fake_boolean(**kwargs):
        del kwargs
        calls["boolean"] += 1
        return None

    monkeypatch.setattr(vuln, "check_sqli_boolean", _fake_boolean)

    out = vuln.scan_vulnerabilities({"target": "http://example.test"}, version="test")
    assert out["errors"] == []
    assert calls["boolean"] == 1


def test_scan_vulnerabilities_skips_boolean_if_sqli_error_exists(monkeypatch):
    pt = vuln.InputPoint(method="GET", path="/rest/products/search", location="query", param="q")

    monkeypatch.setattr(vuln, "derive_input_points_from_scan", lambda doc: [pt])
    monkeypatch.setattr(vuln, "check_reflected_xss", lambda **kwargs: None)
    monkeypatch.setattr(vuln, "check_sqli_error", lambda **kwargs: _make_sql_error_finding(pt))

    calls = {"boolean": 0}

    def _fake_boolean(**kwargs):
        del kwargs
        calls["boolean"] += 1
        return None

    monkeypatch.setattr(vuln, "check_sqli_boolean", _fake_boolean)

    out = vuln.scan_vulnerabilities({"target": "http://example.test"}, version="test")
    assert calls["boolean"] == 0
    assert len(out["findings"]) == 1
    assert out["findings"][0]["type"] == "SQLI_ERROR"
